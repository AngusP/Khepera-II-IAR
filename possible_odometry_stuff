CALIBRATIN STUFF:

http://www-personal.umich.edu/~johannb/Papers/pos96rep.pdf 
http://thetechnicgear.com/2014/06/howto-calibrate-differential-drive-robot/


FORMULAS :

http://web.eecs.utk.edu/~leparker/Courses/CS594-fall08/Lectures/Nov-13-Localization-Mapping-I.pdf
https://www.cs.princeton.edu/courses/archive/fall11/cos495/COS495-Lecture5-Odometry.pdf
https://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/16311/www/s07/labs/NXTLabs/Lab%203.html 


ENCODERS (other stuff is useless in this document):

http://ttuadvancedrobotics.wikidot.com/odometry
-----------------------------------------------------------------------



ODOMETRY V1 (no calibration, dumb formulas based on encoders)
USES https://www.cs.princeton.edu/courses/archive/fall11/cos495/COS495-Lecture5-Odometry.pdf

-----------------------------------------------------------------------

from math import *

TICKS_PER_M = 12000 # encoder ticks per meter
WHEEL_BASE_M = 0.01 # m
MEASUREMENT_PERIOD_S = 0.02 # s


# Class to define state to not have arrays... cause arrays are ugly
class State:
  # time when state recorded
  time 	= 0
  # x location relative to initial placament at time of recording
  x 	= 0
  # y location relative to initial placament at time of recording
  y 	= 0
  # y location relative to initial placament at time of recording
  theta = 0
  # encoder values at the time of recording
  encoder_l = 0
  encoder_r = 0




def delta_l_r(prev_l, prev_r):
	result 		= [0]*2
	odo 		= comms.get_odo()
	delta_l 	= prev_l - odo[0]
	delta_r 	= prev_r - odo[1]
	
	result[0] 	= delta_l
	result[1] 	= delta_r
	return result

def delta_s(prev_l, prev_r):
	result 		= 0
    delta_odo 	= delta_l_r(prev_l, prev_r)
	result 		= ((delta_odo[0] + delta_odo[1]) / 2 ) / TICKS_PER_M 
	
	return result # m

def delfa_theta(prev_l, prev_r):
	result 		= 0
    delta_odo 	= delta_lr(prev_l, prev_r)
	result 		= ((delta_odo[1] - delta_odo[0]) / WHEEL_BASE_M ) / TICKS_PER_M 
	
	return result #radians

def delta_x_y_angle(prev_l, prev_r, curr_theta):
	result 		= [0]*3
	
	delta_dist  = delta_s(prev_l, prev_r)
	delta_angle = delta_theta(prev_l, prev_r)
	delta_x 	= delta_dist*math.cos(curr_theta + delta_angle / 2)
    delta_y 	= delta_dist*math.sin(curr_theta + delta_angle / 2)
    
    #altetrnative (still an approximation) is 
    #delta_x = delta_dist*math.cos(curr_theta + delta_angle )
    #delta_y = delta_dist*math.sin(curr_theta + delta_angle )
    
	
	result[0] = delta_x
	result[1] = delta_y
	result[2] = delta_angle
	
	return result

def new_state(prev_state)

    state_change = delta_x_y_angle(prev_state.encoder_l, prev_state.encoder_r, prev_state.theta)
    
	x_n 	= prev_x 	 + state_change[0]
	y_n 	= prev_y 	 + state_change[1]
	theta_n	= prev_theta + state_change[2]
	
    odo 		= comms.get_odo()
	
	#return new state
	result 		= State() 
	result.time = prev_state.time + t
	result.x 	= x_n
	result.y	= y_n
	
	result.theta 	 = theta_n
	result.encoder_l = odo[0]
	result.encorer_r = odo[1]

	return result
-----------------------------------------------------------------------



ODOMETRY V2 (4th order non-linear equation supposedly should work)
USES https://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/16311/www/s07/labs/NXTLabs/Lab%203.html

-----------------------------------------------------------------------

#TODO check previous methods for SI system
#TODO check if the thing works for equal speeds on both wheels (and previous solutions as well)

from math import *

TICKS_PER_M = 12000 # encoder ticks per meter
WHEEL_BASE_M = 0.01 # m
MEASUREMENT_PERIOD_S = 0.02 # s


# Class to define state to not have arrays... cause arrays are ugly
class State:
  # time when state recorded
  time = 0
  # x location relative to initial placament at time of recording
  x = 0
  # y location relative to initial placament at time of recording
  y = 0
  # y location relative to initial placament at time of recording
  theta = 0
  # encoder values at the time of recording
  encoder_l = 0
  encoder_r = 0



def delta_l_r(prev_l, prev_r):
	result = [0]*2
	odo = comms.get_odo()
	
	delta_l = prev_l - odo[0]
	delta_r = prev_r - odo[1]
	
	result[0] = delta_l
	result[1] = delta_r
	return result
	
def velocity_l_r(prev_l, prev_r):
	
	result = [0]*2
	delta_odo = delta_l_r(prev_l, prev_r)
	
	speed_l = (delta_odo[0] / TICKS_PER_M) /  MEASUREMENT_PERIOD_S # m / s
	speed_r = (delta_odo[1] / TICKS_PER_M) /  MEASUREMENT_PERIOD_S # m / s
	
	result[0] = speed_l
	result[1] = speed_r
	
	return result
	
def velocity_linear_angular(prev_l, prev_r):
	result = [0]*2
	
	velocity_left_right = velocity_l_r(prev_l, prev_r)
	
	velocity_linear = (velocity_left_right[0] + velocity_left_right[1] ) / 2 # m /s
	velocity_angular = (velocity_left_right[1] - velocity_left_right[0] ) / WHEEL_BASE_M # rad / s
	
	result[0] = velocity_linear
	result[1] = velocity_angular
	
	return result
	
	
def	new_state(prev_state):
	
	velocities = velocity_linear_angular(prev_state.encoder_l, prev_state.encoder_r)
	
	v = velocities[0]
	w = velocities[1]
	t = MEASUREMENT_PERIOD_S
	
	prev_theta = prev_state.theta
	prev_x = prev_state.x
	prev_y = prev_state.y

	
	#apply the equation
	k00 = v * math.cos(prev_theta)
	k01 = v * math.sin(prev_theta)
	k02 = w
	
	k10 = v * math.cos(prev_theta + t * k02/2)
	k11 = v * math.sin(prev_theta + t * k02/2)
	k12 = w
	
	k20 = v * math.cos(prev_theta + t * k12/2)
	k21 = v * math.sin(prev_theta + t * k12/2)
	k22 = w	

	k30 = v * math.cos(prev_theta + t * k22/2)
	k31 = v * math.sin(prev_theta + t * k22/2)
	k32 = w		
	
	x_n 	= prev_x 	 + t/6 * (k00 + 2*(k10 + k20) + k30)
	y_n 	= prev_y 	 + t/6 * (k01 + 2*(k11 + k21) + k31)
	theta_n = prev_theta + t/6 * (k02 + 2*(k12 + k22) + k32)
	
	
	
	
    odo = comms.get_odo()
	
	#return new state
	result = State() 
	result.time = prev_state.time + t
	result.x = x_n
	result.y = y_n
	result.theta = theta_n
	result.encoder_l = odo[0]
	result.encorer_r = odo[1]
	
	return result
	
-----------------------------------------------------------------------	
	
	
	
	
	
	
	
	






