
%     %%%%%%%%%%%%%%%
%
%     P A C K A G E S
%
%     %%%%%%%%%%%%%%%

\documentclass[11pt, a4paper]{article}
\usepackage{fontspec} 

% DOCUMENT LAYOUT
\usepackage{geometry} 
\geometry{a4paper, textwidth=5.5in, textheight=8.5in, marginparsep=6pt, marginparwidth=.6in}
\setlength\parindent{0in}

% FONTS
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{xunicode}
\usepackage{xltxtra}
\defaultfontfeatures{Mapping=tex-text}
%\setromanfont [Ligatures={Common}, Numbers={OldStyle}, Variant=01]{Linux Libertine O}
%\setmonofont[Scale=0.8]{Monaco}
%%% modified by Karol Kozio≈Ç for ShareLaTeX use
\setmainfont[
  Ligatures={Common}, Numbers={OldStyle}, Variant=01,
  BoldFont=LinLibertine_RB.otf,
  ItalicFont=LinLibertine_RI.otf,
  BoldItalicFont=LinLibertine_RBI.otf
]{LinLibertine_R.otf}
\setmonofont[Scale=0.8]{DejaVuSansMono.ttf}

% HEADINGS
\usepackage{sectsty} 
\usepackage[normalem]{ulem} 
\sectionfont{\mdseries\upshape\Large}
\subsectionfont{\mdseries\scshape\normalsize} 
\subsubsectionfont{\mdseries\upshape\large} 


%     %%%%%%%%%%%%%%%
%
%     D O C U M E N T
%
%     %%%%%%%%%%%%%%%

\begin{document}

\title{IAR Task 1 Report}
\author{s1311631, s1346981}
\date{\today}
\maketitle

%       ^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^

\section{Introduction}

The first assignment entails utilising the infra-red distance sensors on the Kephera 
robot to move around in an autonomous fashion, whilst avoiding obstacles and tending 
to follow walls. The Robot is controlled remotely controlled over serial. We have 
elected to use Python as the implementation language for this practical.

The task requires that the robot be able to autonomously move around it's environment,
``without hitting obstacles or getting stuck in corners or dead-ends. Second, it should 
tend to follow long walls, keeping a consistent distance away from the wall.''

Our approach was to investigate the efficacy of PID controlers to acheive 
these behaviours - With PID, maintaining a constant distance from a wall arises as
a behaviour naturally, given the controller will always be attempting to zero the 
error, which is a distance to the wall. Built ontop of PID are control methods to
allow the robot to navigate away from an obstacle.

%       ^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^

\section{Exploring Different Methods of Obstacle Avoidance}

\subsection{PID Ease-Off Error Mitigation}

% Commit 5837a4b

The first iteration used the distance-derived errors from the forward-facing 
sensors only. When the error passes a set threshold, where the wall is within a 
fixed distance from the robot, we stop moving forwards and instead turn \emph{away} 
from the side that is close to the wall until the error has reduced to below the 
threshold.

We use only the two forward-facing sensors to determine if an obstacle is too close, 
and use the two angled sensors adjacent to them to inform the direction in which to 
turn.

This approach had some promising behaviours: The robot was able to prevent itself 
from hitting a small object directly in it's path; Similarly it was able to follow 
a straight wall to some degree. However, wall following would either oscillate 
towards the wall, bumping against it or depart after following for a short distance. 

% Commit f1258e7

We then augmented this method with the distance and PID error data from the other
forward-facing sensors, having the effect of widening the Robot's field of view.
This prevented the robot from colliding with the wall as the side-facing sensors 
are now involved in the navigation. Furthermore, the robot will turn in a curved path
when the wall is approaching but not very close, and will turn on the spot if the 
robot is stuck in a corner or is very close to an obstacle. Additionally, the Robot 
corrects minimally to ensure it's distance to the wall is below the threshold; This 
allows it to follow a wall for a long distance.

% Commit cc5b195

The robot is still getting stuck in corners and struggles with indecision wrt. which way to turn

Problems presented tuning PID

Namedrop Bug2

\subsection{Force-Vector Control}

As an alternative method we consider treating the Error vector produced by the
PID Controller for each distance sensor and treating them as the magnitudes of a 
force pushing the robot along the axis of said sensor. Summing these force vectors
gives us an `Intended Direction' vector, which is used to correct the current 
trajectory away from the obstacle.

Experimentation indicates this method does not perform as well as the PID ease-off 
method above, as it is prone to `wobbling' from noisy sensor data, and does not
exhibit wall-following behaviour as the error vectors push in direct opposition to 
the wall, resulting in an incident-reflection equivalence in the angle the robot
takes to the wall.

Attempts to improve this method of control included thresholding the forces, to 
prevent minor perturbations and noise from causing an overreaction; The forces are 
also scaled in relation to the magnitude of the error/`closeness to obstacle' we're 
experiencing : This too prevents some wobble but the combination of these changes 
reduce the reactivity of this force-vector method, giving the robot poor performance 
in any environment with acute angles and unsmooth edges.

The method is, however, somewhat more elegant than PID \& rule based control insofar 
as the complexity of behaviour that emerges from a simple rule set. Nonetheless, we 
discard Force-Vector control in favour of PID derived control.

%       ^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^

\section{Developing Wall-Following Behaviour}

The existing obstacle-avoidance does develop some wall-following-like behaviour, 
yet fails to follow \emph{at a constant distance} due to the fact it will turn until 
the wall is no longer in front of it, but has no problem with overcorrecting by 
some acute angle nor does it's concept of error make it seek out a wall to hug.

We can observe that our PID controller gives us a per-sensor, independent `error' - 
A negative value, we are too far from the wall and symmetrically a positive is 
indicative that we're too close to an object. For the purposes of \emph{avoiding} 
a collision we only act on these errors when they pass from nagative to positive; 
but to follow a wall we are trying to ensure the error for a specific sensor is 
as close to 0 as possible, and any deviation be corrected.

%       ^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^

\section{Physical Limitations and Possible Improvements}

The Khepera's distance sensors are spaced to prioritise forward motion, which is handy 
for exploring a space though does make reversing out of a dead-end much harder than 
turning on the spot then driving out forwards.

Evenly spaced sensors

RF Serial on top

\end{document}
